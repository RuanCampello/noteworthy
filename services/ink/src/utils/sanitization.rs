use lazy_static::lazy_static;
use regex::Regex;
use sanitize_html::rules::pattern::Pattern;
use sanitize_html::rules::{Element, Rules};
use sanitize_html::sanitize_str;
use tracing::info;

lazy_static! {
  static ref RULES: Rules = untrusted();
  /// Removes any HTML tag or empty spaces.
  static ref TAG_REGEX: Regex = Regex::new(r"<[^>]+>|&nbsp;").expect("Invalid regex");
  /// Used for the custom `<search>` tag generated by searching.
  static ref SEARCH_REGEX: Regex = Regex::new(r"<search>.*?</search>").expect("Invalid regex");
}

fn re(regex: &str) -> Pattern {
  Pattern::regex(Regex::new(regex).unwrap())
}

fn href() -> Pattern {
  re("^(ftp:|http:|https:|mailto:)") | !re("^[^/]+[[:space:]]*:")
}

fn untrusted() -> Rules {
  Rules::new()
    .element(
      Element::new("a")
        .attribute("href", href())
        .mandatory_attribute("target", "_blank")
        .mandatory_attribute("rel", "noreferrer noopener"),
    )
    .element(Element::new("b"))
    .element(Element::new("em"))
    .element(Element::new("i"))
    .element(Element::new("strong"))
    .element(Element::new("u"))
    .element(Element::new("span").attribute("class", re(r"text-slate")))
    .space("address")
    .space("article")
    .space("aside")
    .space("blockquote")
    .space("br")
    .space("dd")
    .space("div")
    .space("dl")
    .space("dt")
    .space("footer")
    .space("h1")
    .space("h2")
    .space("h3")
    .space("h4")
    .space("h5")
    .space("h6")
    .space("header")
    .space("hgroup")
    .space("hr")
    .space("li")
    .space("nav")
    .space("ol")
    .space("p")
    .space("pre")
    .space("section")
    .space("ul")
}
/// Replaces the custom `<search>` tags with highlighted spans
fn replace_search_tags(input: &str) -> String {
  input
    .replace("<search>", "<span class='text-slate'>")
    .replace("</search>", "</span>")
}

pub trait Sanitize {
  fn sanitize_html(&self) -> String;
}

impl Sanitize for String {
  fn sanitize_html(&self) -> String {
    let mut stripped_content = TAG_REGEX.replace_all(self, "").into_owned();

    if SEARCH_REGEX.is_match(self) {
      stripped_content = replace_search_tags(self);
    }

    sanitize_str(&RULES, &stripped_content).expect("Invalid HTML")
  }
}
